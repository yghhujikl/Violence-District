do local _genv=getfenv(0);local function _g(name) return _genv[name];end local _ismouse1pressed=function() return _g("ismouse1pressed")();end;local _ismouse2pressed=function() return _g("ismouse2pressed")();end;local _mouse1press=function() return _g("mouse1press")();end;local _mouse1release=function() return _g("mouse1release")();end;local _mouse2press=function() return _g("mouse2press")();end;local _mouse2release=function() return _g("mouse2release")();end;local _mouse2click=function() return _g("mouse2click")();end;local _iskeypressed=function(k) return _g("iskeypressed")(k);end;local _keypress=function(k) return _g("keypress")(k);end;local _keyrelease=function(k) return _g("keyrelease")(k);end;local _setrobloxinput=function(v) return _g("setrobloxinput")(v);end;local _Drawing=setmetatable({},{__index=function(_,k) return _g("Drawing")[k];end});local _WorldToScreen=function(v) return _g("WorldToScreen")(v);end;local players=game:GetService("Players");local localPlayer=players.LocalPlayer;local UserInputService=game:GetService("UserInputService");local COLORS={Survivors=Color3.fromRGB(80,200,140),Killer=Color3.fromRGB(220,90,90),Spectator=Color3.fromRGB(160,160,180),dim=Color3.fromRGB(140,140,155),white=Color3.fromRGB(220,220,225),Generator=Color3.fromRGB(255,220,50),Pallet=Color3.fromRGB(180,120,60),Window=Color3.fromRGB(80,160,255)};local FONT=_Drawing.Fonts.Monospace;local validWeapons={["Twist of Fate"]=true,["Motion Tracker"]=true,Gate=true,Flashlight=true,Bandage=true,["Parrying Dagger"]=true,["Adrenaline Shot"]=true,["Shadow Clone"]=true,["WaxBound Candle"]=true};local S={enabled=true,showSurvivors=true,showKillers=true,showSpectators=true,showGenerators=true,showPallets=true,showWindows=true,showCrosshair=false,showGunCrosshair=false,showNames=true,teleportEnabled=true,toggleKey=113,changingKeybind=false,currentTab="ESP",maxWaypoints=21,selectedWP=nil,autoSkillCheck=false,chamsEnabled=false,autoParryEnabled=false,pingMode="high"};local PING_DELAYS={high=0,mid=0.1,low=0.2};local function KeyNames(k) if (k==32) then return "Space";end if (k==13) then return "Enter";end if (k==16) then return "Shift";end if (k==17) then return "Ctrl";end if (k==18) then return "Alt";end if ((k>=48) and (k<=57)) then return tostring(k-48 );end if ((k>=65) and (k<=90)) then return string.char(k);end if ((k>=112) and (k<=123)) then return "F"   .. tostring(k-111 ) ;end return nil;end local function isKey(k) return _iskeypressed(k);end local function isM1() return ismouse1pressed();end local playerESP={};local objectESP={};local waypoints={};local LIMB_DEFS={"Head","Torso","Left Arm","Right Arm","Left Leg","Right Leg"};local EDGES={{1,2},{1,3},{2,4},{3,4},{5,6},{5,7},{6,8},{7,8},{1,5},{2,6},{3,7},{4,8}};local chamsESP={};local function getCornersCh(part) local ok1,pos=pcall(function() return part.Position;end);local ok2,size=pcall(function() return part.Size;end);if ( not ok1 or  not ok2 or  not pos or  not size) then return nil;end local hx,hy,hz=size.X * 0.5 ,size.Y * 0.5 ,size.Z * 0.5 ;return {Vector3.new(pos.X,pos.Y-hy ,pos.Z-hz ),Vector3.new(pos.X,pos.Y-hy ,pos.Z + hz ),Vector3.new(pos.X,pos.Y + hy ,pos.Z-hz ),Vector3.new(pos.X,pos.Y + hy ,pos.Z + hz ),Vector3.new(pos.X + (hx * 2) ,pos.Y-hy ,pos.Z-hz ),Vector3.new(pos.X + (hx * 2) ,pos.Y-hy ,pos.Z + hz ),Vector3.new(pos.X + (hx * 2) ,pos.Y + hy ,pos.Z-hz ),Vector3.new(pos.X + (hx * 2) ,pos.Y + hy ,pos.Z + hz )};end local function newLimbBox() local lines={};for i=1,12 do local l=_Drawing.new("Line");l.Visible=false;l.Thickness=1.5;l.Transparency=1;l.ZIndex=5;l.Color=Color3.fromRGB(255,255,255);lines[i]=l;end return lines;end local function newChamsEntry(p) if chamsESP[p.Name] then return;end local limbs={};for _,name in ipairs(LIMB_DEFS) do limbs[name]=newLimbBox();end chamsESP[p.Name]={player=p,limbs=limbs};end local function removeChamsEntry(name) local d=chamsESP[name];if  not d then return;end for _,lines in pairs(d.limbs) do for _,l in ipairs(lines) do pcall(function() l:Remove();end);end end chamsESP[name]=nil;end local function hideChamLines(lines) for _,l in ipairs(lines) do l.Visible=false;end end local function hideChamsEntry(d) for _,lines in pairs(d.limbs) do hideChamLines(lines);end end local function drawChamsBox(lines,corners,col) local sc={};local anyOn=false;for i,wp in ipairs(corners) do local sp,on=_WorldToScreen(wp);if on then anyOn=true;end sc[i]=(on and sp) or nil ;end if  not anyOn then hideChamLines(lines);return false;end for i,edge in ipairs(EDGES) do local a=sc[edge[1]];local b=sc[edge[2]];local l=lines[i];if (a and b) then l.From=a;l.To=b;l.Color=col;l.Visible=true;else l.Visible=false;end end return true;end local function isLocal(p) return p.Name==localPlayer.Name ;end function teamColorFn(p) if  not p.Team then return COLORS.dim;end return COLORS[p.Team.Name] or COLORS.dim ;end local function updateChamsESP() if ( not S.enabled or  not S.chamsEnabled) then for _,d in pairs(chamsESP) do hideChamsEntry(d);end return;end for _,p in ipairs(players:GetPlayers()) do if ( not isLocal(p) and p.Character and  not chamsESP[p.Name]) then newChamsEntry(p);end end for name,d in pairs(chamsESP) do local p=d.player;if isLocal(p) then hideChamsEntry(d);elseif (p and p.Parent and p.Character) then local hum=p.Character:FindFirstChildOfClass("Humanoid");if (hum and (hum.Health>0)) then local col=teamColorFn(p);for _,partName in ipairs(LIMB_DEFS) do local lines=d.limbs[partName];local part=p.Character:FindFirstChild(partName);if part then local corners=getCornersCh(part);if corners then drawChamsBox(lines,corners,col);else hideChamLines(lines);end else hideChamLines(lines);end end else hideChamsEntry(d);end else hideChamsEntry(d);end end for name in pairs(chamsESP) do local found=false;for _,p in ipairs(players:GetPlayers()) do if (p.Name==name) then found=true;break;end end if  not found then removeChamsEntry(name);end end end local MemoryManager,skillLoaded=nil,false;local function LoadMM() if skillLoaded then return true;end pcall(function() local base="C:/matcha/workspace/ViolenceDistrict/Modules/";if  not isfolder("C:/matcha/workspace/ViolenceDistrict/") then makefolder("C:/matcha/workspace/ViolenceDistrict/");end if  not isfolder(base) then makefolder(base);end local url="https://raw.githubusercontent.com/thelucas128/Macha/refs/heads/main/MemoryManagerFixed.luau";local src=game:HttpGet(url);local path=base   .. "MemoryManager.lua" ;if ( not isfile(path) or (readfile(path)~=src)) then writefile(path,src);end MemoryManager=require(path);skillLoaded=true;end);return skillLoaded;end local function normAng(a) a=a%360 ;return ((a<0) and (a + 360)) or a ;end local function AutoSkillCheck() if ( not S.autoSkillCheck or  not skillLoaded or  not MemoryManager) then return;end local pg=localPlayer:FindFirstChild("PlayerGui");if  not pg then return;end local cp=pg:FindFirstChild("SkillCheckPromptGui");if  not cp then return;end pcall(function() local r=normAng(MemoryManager.GetGuiObjectRotation(cp.Check.Line.Address));local gr=normAng(MemoryManager.GetGuiObjectRotation(cp.Check.Goal.Address));local lo=normAng(104 + gr );local hi=normAng(114 + gr );local neu=normAng(159 + gr );if (((lo<=r) and (r<=hi)) or ((hi<r) and (r<=neu))) then _keypress(32);_keyrelease(32);end end);end spawn(function() while true do wait(1);if (S.autoSkillCheck and  not skillLoaded) then if  not LoadMM() then S.autoSkillCheck=false;end end end end);local CH={};local function mkLine(color,zi) local l=_Drawing.new("Line");l.Visible=false;l.Thickness=1.5;l.Transparency=1;l.Color=color;l.ZIndex=zi;return l;end CH.h=mkLine(Color3.fromRGB(240,240,240),100);CH.v=mkLine(Color3.fromRGB(240,240,240),100);CH.gh=mkLine(Color3.fromRGB(255,80,80),101);CH.gv=mkLine(Color3.fromRGB(255,80,80),101);local function updateCrosshair() local sv=workspace.CurrentCamera.ViewportSize;local cx,cy,sz=sv.X/2 ,sv.Y/2 ,10;CH.h.Visible=S.showCrosshair;CH.v.Visible=S.showCrosshair;CH.gh.Visible=S.showGunCrosshair;CH.gv.Visible=S.showGunCrosshair;if S.showCrosshair then CH.h.From=Vector2.new(cx-sz ,cy);CH.h.To=Vector2.new(cx + sz ,cy);CH.v.From=Vector2.new(cx,cy-sz );CH.v.To=Vector2.new(cx,cy + sz );end if S.showGunCrosshair then local gx=cx-15 ;CH.gh.From=Vector2.new(gx-sz ,cy);CH.gh.To=Vector2.new(gx + sz ,cy);CH.gv.From=Vector2.new(gx,cy-sz );CH.gv.To=Vector2.new(gx,cy + sz );end end local function hpColor(p) if (p>0.6) then return Color3.fromRGB(80,200,140);elseif (p>0.3) then return Color3.fromRGB(220,190,80);else return Color3.fromRGB(210,80,80);end end local function mkCorners(c) local t={};for i=1,8 do local l=_Drawing.new("Line");l.Visible=false;l.Color=c;l.Thickness=1.5;l.Transparency=1;l.ZIndex=3;t[i]=l;end return t;end local function drawCorners(t,x,y,w,h,c) local s=math.max(math.min(w,h) * 0.28 ,7);for i=1,8 do t[i].Color=c;t[i].Visible=true;end t[1].From=Vector2.new(x,y);t[1].To=Vector2.new(x + s ,y);t[2].From=Vector2.new(x,y);t[2].To=Vector2.new(x,y + s );t[3].From=Vector2.new(x + w ,y);t[3].To=Vector2.new((x + w) -s ,y);t[4].From=Vector2.new(x + w ,y);t[4].To=Vector2.new(x + w ,y + s );t[5].From=Vector2.new(x,y + h );t[5].To=Vector2.new(x + s ,y + h );t[6].From=Vector2.new(x,y + h );t[6].To=Vector2.new(x,(y + h) -s );t[7].From=Vector2.new(x + w ,y + h );t[7].To=Vector2.new((x + w) -s ,y + h );t[8].From=Vector2.new(x + w ,y + h );t[8].To=Vector2.new(x + w ,(y + h) -s );end local function hideCorners(t) for i=1,8 do t[i].Visible=false;end end local function mkText(sz,c,zi) local t=_Drawing.new("Text");t.Visible=false;t.Center=true;t.Outline=false;t.Font=FONT;t.Size=sz;t.Color=c;t.ZIndex=zi or 4 ;t.Text="";return t;end local function mkBar() local bg=_Drawing.new("Line");bg.Visible=false;bg.Thickness=3;bg.Transparency=1;bg.ZIndex=2;bg.Color=Color3.fromRGB(20,20,20);local fi=_Drawing.new("Line");fi.Visible=false;fi.Thickness=3;fi.Transparency=1;fi.ZIndex=3;fi.Color=Color3.fromRGB(80,200,140);return {bg=bg,fi=fi};end local function drawBar(b,x,y,h,pct) b.bg.From=Vector2.new(x,y);b.bg.To=Vector2.new(x,y + h );b.bg.Visible=true;local fh=h * math.clamp(pct,0,1) ;b.fi.From=Vector2.new(x,(y + h) -fh );b.fi.To=Vector2.new(x,y + h );b.fi.Color=hpColor(pct);b.fi.Visible=true;end local function hideBar(b) b.bg.Visible=false;b.fi.Visible=false;end local blurOverlay=_Drawing.new("Square");blurOverlay.Visible=false;blurOverlay.Filled=true;blurOverlay.ZIndex=8;blurOverlay.Color=Color3.fromRGB(0,0,0);blurOverlay.Transparency=0.45;blurOverlay.Position=Vector2.new(0,0);local function updateBlur() local sv=workspace.CurrentCamera.ViewportSize;blurOverlay.Size=Vector2.new(sv.X,sv.Y);end local function teamName(p) if  not p.Team then return "?";end return p.Team.Name;end local function myPos() local c=localPlayer.Character;if  not c then return nil;end local h=c:FindFirstChild("HumanoidRootPart");return (h and h.Position) or nil ;end local function getWeapon(p) if  not p.Character then return nil;end for _,v in pairs(p.Character:GetChildren()) do if (v:IsA("LocalScript") and validWeapons[v.Name]) then return v.Name;end end return nil;end local function shouldShow(p) if ( not p or  not p.Team) then return false;end local t=p.Team.Name;if ((t=="Survivors") and  not S.showSurvivors) then return false;end if ((t=="Killer") and  not S.showKillers) then return false;end if ((t=="Spectator") and  not S.showSpectators) then return false;end return true;end local function createESP(p) if playerESP[p.Name] then return;end playerESP[p.Name]={player=p,corners=mkCorners(COLORS.dim),bar=mkBar(),name=mkText(13,COLORS.white,5),role=mkText(11,COLORS.dim,5),dist=mkText(11,COLORS.dim,5),tool=mkText(11,COLORS.white,5)};end local function removeESP(n) local d=playerESP[n];if  not d then return;end hideCorners(d.corners);hideBar(d.bar);d.name.Visible=false;d.role.Visible=false;d.dist.Visible=false;d.tool.Visible=false;for _,l in ipairs(d.corners) do pcall(function() l:Remove();end);end for _,k in ipairs({"bg","fi"}) do pcall(function() d.bar[k]:Remove();end);end for _,k in ipairs({"name","role","dist","tool"}) do pcall(function() d[k]:Remove();end);end playerESP[n]=nil;end local function updatePlayerESP() if  not S.enabled then for _,d in pairs(playerESP) do hideCorners(d.corners);hideBar(d.bar);d.name.Visible=false;d.role.Visible=false;d.dist.Visible=false;d.tool.Visible=false;end return;end for _,p in ipairs(players:GetPlayers()) do if ((p~=localPlayer) and p.Character) then createESP(p);end end local mp=myPos();for n,d in pairs(playerESP) do local p=d.player;local ok=false;if (p and p.Parent and p.Character and shouldShow(p)) then local hrp=p.Character:FindFirstChild("HumanoidRootPart");local head=p.Character:FindFirstChild("Head");local hum=p.Character:FindFirstChildOfClass("Humanoid");if (hrp and hum and (hum.Health>0)) then local hp=(head and head.Position) or (hrp.Position + Vector3.new(0,1.5,0)) ;local fp=hrp.Position-Vector3.new(0,3,0) ;local sH,onH=_WorldToScreen(hp);local sF,onF=_WorldToScreen(fp);if (onH and onF) then local col=teamColorFn(p);local role=teamName(p);local wpn=getWeapon(p);local pct=hum.Health/math.max(hum.MaxHealth,1) ;local h=math.max(math.abs(sF.Y-sH.Y ),40);local w=math.max(h * 0.5 ,24);local top=math.min(sH.Y,sF.Y);local cx=sH.X;local x=cx-(w * 0.5) ;local dist=0;if mp then local dx=hrp.Position.X-mp.X ;local dy=hrp.Position.Y-mp.Y ;local dz=hrp.Position.Z-mp.Z ;dist=math.sqrt((dx * dx) + (dy * dy) + (dz * dz) );end if  not S.chamsEnabled then drawCorners(d.corners,x,top,w,h,col);drawBar(d.bar,x-5 ,top,h,pct);else hideCorners(d.corners);hideBar(d.bar);end if S.showNames then d.name.Text=p.Name;d.name.Color=col;d.name.Position=Vector2.new(cx,top-17 );d.name.Visible=true;else d.name.Visible=false;end d.role.Text=role;d.role.Color=col;d.role.Position=Vector2.new(cx,top + h + 3 );d.role.Visible=true;d.dist.Text=math.floor(dist)   .. "m" ;d.dist.Position=Vector2.new(cx,top + h + 15 );d.dist.Visible=true;if wpn then d.tool.Text=wpn;d.tool.Position=Vector2.new(cx,top + h + 27 );d.tool.Visible=true;else d.tool.Visible=false;end ok=true;end end end if  not ok then hideCorners(d.corners);hideBar(d.bar);d.name.Visible=false;d.role.Visible=false;d.dist.Visible=false;d.tool.Visible=false;end end for n in pairs(playerESP) do local f=false;for _,p in ipairs(players:GetPlayers()) do if (p.Name==n) then f=true;break;end end if  not f then removeESP(n);end end end local function objPos(o) local iw=o:FindFirstChild("inviswall");if (iw and iw:IsA("BasePart")) then return iw.Position;end local pp=o:FindFirstChild("PalletPoint");if (pp and pp:IsA("BasePart")) then return pp.Position;end local hb=o:FindFirstChild("HitBox");if (hb and hb:IsA("BasePart")) then return hb.Position;end if o.PrimaryPart then return o.PrimaryPart.Position;end for _,c in pairs(o:GetDescendants()) do if c:IsA("BasePart") then return c.Position;end end return nil;end local function createObjESP(o,label,color) if objectESP[o] then local d=objectESP[o];hideCorners(d.corners);d.name.Visible=false;d.dist.Visible=false;for _,l in ipairs(d.corners) do pcall(function() l:Remove();end);end pcall(function() d.name:Remove();end);pcall(function() d.dist:Remove();end);objectESP[o]=nil;end objectESP[o]={corners=mkCorners(color),name=mkText(12,color,5),dist=mkText(11,COLORS.dim,5),label=label,color=color};end local function removeObjESP(o) local d=objectESP[o];if  not d then return;end hideCorners(d.corners);d.name.Visible=false;d.dist.Visible=false;for _,l in ipairs(d.corners) do pcall(function() l:Remove();end);end pcall(function() d.name:Remove();end);pcall(function() d.dist:Remove();end);objectESP[o]=nil;end local function updateObjectESP() if  not S.enabled then for _,d in pairs(objectESP) do hideCorners(d.corners);d.name.Visible=false;d.dist.Visible=false;end return;end local mp=myPos();for o,d in pairs(objectESP) do local ok=false;local show=((d.label=="Generator") and S.showGenerators) or ((d.label=="Pallet") and S.showPallets) or ((d.label=="Window") and S.showWindows) ;if (o and o.Parent and show) then local pos=objPos(o);if pos then local sT,onT=_WorldToScreen(pos + Vector3.new(0,5,0) );local sB,onB=_WorldToScreen(pos-Vector3.new(0,5,0) );if (onT and onB) then local dist=0;if mp then local dx=pos.X-mp.X ;local dy=pos.Y-mp.Y ;local dz=pos.Z-mp.Z ;dist=math.sqrt((dx * dx) + (dy * dy) + (dz * dz) );end local h=math.max(math.abs(sT.Y-sB.Y ),40);local w=math.max(h * 0.8 ,30);local cx=sT.X;drawCorners(d.corners,cx-(w * 0.5) ,sT.Y,w,h,d.color);if S.showNames then d.name.Text=d.label;d.name.Position=Vector2.new(cx,sT.Y-15 );d.name.Visible=true;else d.name.Visible=false;end d.dist.Text=math.floor(dist)   .. "m" ;d.dist.Position=Vector2.new(cx,sT.Y + h + 3 );d.dist.Visible=true;ok=true;end end end if  not ok then hideCorners(d.corners);d.name.Visible=false;d.dist.Visible=false;end if ( not o or  not o.Parent) then removeObjESP(o);end end end local function findR(parent,name) local f={};for _,c in pairs(parent:GetChildren()) do if (c.Name==name) then table.insert(f,c);end if (c:IsA("Folder") or c:IsA("Model")) then for _,v in pairs(findR(c,name)) do table.insert(f,v);end end end return f;end local function scanType(oName,label,color) local map=workspace:FindFirstChild("Map");if  not map then return;end for o,d in pairs(objectESP) do if (d.label==label) then removeObjESP(o);end end for _,o in ipairs(findR(map,oName)) do if (o and o.Parent) then createObjESP(o,label,color);end end end local function scanLoop(oName,label,color,interval) spawn(function() wait(1);scanType(oName,label,color);while true do wait(interval);scanType(oName,label,color);end end);end local function myHRP() local c=localPlayer.Character;if  not c then return nil;end return c:FindFirstChild("HumanoidRootPart");end local function teleportLobby() local hrp=myHRP();if  not hrp then return;end local lobby=workspace:FindFirstChild("Lobby");if  not lobby then return;end local car=lobby:FindFirstChild("CarLobby");if  not car then return;end local part=car:FindFirstChild("Part");if  not part then return;end hrp.Position=part.Position + Vector3.new(0,5,0) ;end local function saveWP() if ( #waypoints>=S.maxWaypoints) then return;end local hrp=myHRP();if  not hrp then return;end local p=hrp.Position;table.insert(waypoints,{x=p.X,y=p.Y,z=p.Z,name="Waypoint "   .. ( #waypoints + 1) });end local function deleteWP() local i=S.selectedWP;if ( not i or (i<1) or (i> #waypoints)) then return;end table.remove(waypoints,i);S.selectedWP=nil;end local function teleportWP() local i=S.selectedWP;if ( not i or (i<1) or (i> #waypoints)) then return;end local hrp=myHRP();if  not hrp then return;end local w=waypoints[i];if w then hrp.Position=Vector3.new(w.x,w.y,w.z);end end local function tpPlayerCH() if  not S.teleportEnabled then return;end local sv=workspace.CurrentCamera.ViewportSize;local cx,cy=sv.X/2 ,sv.Y/2 ;for _,d in pairs(playerESP) do if d.corners[1].Visible then local bx=d.corners[1].From.X;local by=d.corners[1].From.Y;local bw=d.corners[3].From.X-bx ;local bh=d.corners[5].From.Y-by ;if ((cx>=bx) and (cx<=(bx + bw)) and (cy>=by) and (cy<=(by + bh))) then local p=d.player;if (p and p.Character) then local th=p.Character:FindFirstChild("HumanoidRootPart");local mh=myHRP();if (th and mh) then mh.Position=th.Position + Vector3.new(0,0,3) ;end end return;end end end end local function tpGenCH() if  not S.teleportEnabled then return;end local sv=workspace.CurrentCamera.ViewportSize;local cx,cy=sv.X/2 ,sv.Y/2 ;for o,d in pairs(objectESP) do if ((d.label=="Generator") and d.corners[1].Visible) then local bx=d.corners[1].From.X;local by=d.corners[1].From.Y;local bw=d.corners[3].From.X-bx ;local bh=d.corners[5].From.Y-by ;if ((cx>=bx) and (cx<=(bx + bw)) and (cy>=by) and (cy<=(by + bh))) then local pos=objPos(o);local mh=myHRP();if (pos and mh) then mh.Position=Vector3.new(pos.X,pos.Y,pos.Z + 5 );end return;end end end end local origB,origI;local function unlockMouse() pcall(function() origB=UserInputService.MouseBehavior;origI=UserInputService.MouseIconEnabled;UserInputService.MouseBehavior=Enum.MouseBehavior.Default;UserInputService.MouseIconEnabled=true;end);end local function restoreMouse() pcall(function() if origB then UserInputService.MouseBehavior=origB;end if (origI~=nil) then UserInputService.MouseIconEnabled=origI;end end);end local NCOL={on=Color3.fromRGB(70,210,110),off=Color3.fromRGB(210,70,70),info=Color3.fromRGB(80,138,255),warn=Color3.fromRGB(225,165,35)};local NOTIF_W=240;local NOTIF_H=52;local NOTIF_PAD=6;local NOTIF_DUR=3.2;local NOTIF_FADE=0.5;local notifList={};local function repositionNotifs() local sv=workspace.CurrentCamera.ViewportSize;local rx=(sv.X-NOTIF_W) -12 ;for i,n in ipairs(notifList) do local ty=12 + ((i-1) * (NOTIF_H + NOTIF_PAD)) ;if n.bg then n.bg.Position=Vector2.new(rx,ty);end if n.bar then n.bar.Position=Vector2.new(rx,ty);n.bar.Size=Vector2.new(3,NOTIF_H);end if n.t1 then n.t1.Position=Vector2.new(rx + 12 ,ty + 8 );end if n.t2 then n.t2.Position=Vector2.new(rx + 12 ,ty + 26 );end end end local function destroyNotif(n) for i,v in ipairs(notifList) do if (v==n) then table.remove(notifList,i);break;end end pcall(function() n.bg:Remove();end);pcall(function() n.bar:Remove();end);pcall(function() n.t1:Remove();end);pcall(function() n.t2:Remove();end);repositionNotifs();end local function showNotif(title,sub,ntype) ntype=ntype or "info" ;local ac=NCOL[ntype] or NCOL.info ;if ( #notifList>=6) then destroyNotif(notifList[ #notifList]);end local sv=workspace.CurrentCamera.ViewportSize;local rx=(sv.X-NOTIF_W) -12 ;local ty=12;local bg=_Drawing.new("Square");bg.Visible=true;bg.Filled=true;bg.ZIndex=300;bg.Transparency=1;bg.Color=Color3.fromRGB(17,17,21);bg.Position=Vector2.new(rx,ty);bg.Size=Vector2.new(NOTIF_W,NOTIF_H);local bar=_Drawing.new("Square");bar.Visible=true;bar.Filled=true;bar.ZIndex=301;bar.Transparency=1;bar.Color=ac;bar.Position=Vector2.new(rx,ty);bar.Size=Vector2.new(3,NOTIF_H);local t1=_Drawing.new("Text");t1.Visible=true;t1.ZIndex=302;t1.Center=false;t1.Outline=false;t1.Font=2;t1.Size=14;t1.Transparency=1;t1.Color=Color3.fromRGB(220,220,228);t1.Position=Vector2.new(rx + 12 ,ty + 8 );t1.Text=title;local t2=_Drawing.new("Text");t2.Visible=true;t2.ZIndex=302;t2.Center=false;t2.Outline=false;t2.Font=FONT;t2.Size=12;t2.Transparency=1;t2.Color=ac;t2.Position=Vector2.new(rx + 12 ,ty + 26 );t2.Text=sub or "" ;local notifObj={bg=bg,bar=bar,t1=t1,t2=t2};table.insert(notifList,1,notifObj);repositionNotifs();spawn(function() wait(NOTIF_DUR);local steps=20;for i=1,steps do local a=1 -(i/steps) ;pcall(function() bg.Transparency=a;bar.Transparency=a;t1.Transparency=a;t2.Transparency=a;end);wait(NOTIF_FADE/steps );end destroyNotif(notifObj);end);end local function notifyToggle(name,state) if state then showNotif("Activated",name   .. " turned ON" ,"on");else showNotif("Deactivated",name   .. " turned OFF" ,"off");end end local WM={};local wmPos=Vector2.new(10,10);local wmDragging=false;local wmDragStart,wmDragBase=nil,nil;local function buildWatermark() for _,v in pairs(WM) do pcall(function() v:Remove();end);end WM={};local txt="Violence District  |  "   .. localPlayer.Name ;local approxW=( #txt * 7.4) + 14 ;local H2=24;WM.bg=_Drawing.new("Square");WM.bg.Visible=true;WM.bg.Filled=true;WM.bg.ZIndex=300;WM.bg.Transparency=1;WM.bg.Color=Color3.fromRGB(13,13,17);WM.bg.Position=wmPos;WM.bg.Size=Vector2.new(approxW,H2);WM.line=_Drawing.new("Square");WM.line.Visible=true;WM.line.Filled=true;WM.line.ZIndex=301;WM.line.Transparency=1;WM.line.Color=Color3.fromRGB(92,138,255);WM.line.Position=wmPos;WM.line.Size=Vector2.new(approxW,1);WM.txt=_Drawing.new("Text");WM.txt.Visible=true;WM.txt.ZIndex=302;WM.txt.Center=false;WM.txt.Outline=false;WM.txt.Font=2;WM.txt.Size=13;WM.txt.Transparency=1;WM.txt.Color=Color3.fromRGB(200,200,212);WM.txt.Position=wmPos + Vector2.new(8,5) ;WM.txt.Text=txt;WM._w=approxW;WM._h=H2;end local function moveWM(p) wmPos=p;if WM.bg then WM.bg.Position=p;end if WM.line then WM.line.Position=p;end if WM.txt then WM.txt.Position=p + Vector2.new(8,5) ;end end local function wmHit(m) return (m.X>=wmPos.X) and (m.X<=(wmPos.X + (WM._w or 200))) and (m.Y>=wmPos.Y) and (m.Y<=(wmPos.Y + (WM._h or 24))) ;end local CL={};local clPos=Vector2.new(960,90);local clDragging=false;local clDragStart,clDragBase=nil,nil;local clVisible=true;local clDead=false;local CL_W=260;local CL_H=400;local CL_TH=30;local CHANGELOG_ENTRIES={{version="v4.0",date="2025-02-17",changes={"Added Auto Parry tab with ping modes.","Integrated into main ESP menu."}},{version="v3.0",date="2025-02-17",changes={"Added changelogs and chams."}}};local BX={bg=Color3.fromHex("#111114"),panel=Color3.fromHex("#18181c"),title=Color3.fromHex("#0d0d10"),tabBr=Color3.fromHex("#0a0a0d"),tabOn=Color3.fromHex("#2a2a32"),tabOf=Color3.fromHex("#111114"),btn=Color3.fromHex("#1e1e24"),acc=Color3.fromHex("#5c8aff"),accD=Color3.fromHex("#3a5ab0"),close=Color3.fromHex("#c83c3c"),white=Color3.fromHex("#e0e0e8"),dim=Color3.fromHex("#7a7a8a"),sep=Color3.fromHex("#2a2a35")};local function sq(zi,col,pos,size,fill) local s=_Drawing.new("Square");s.Visible=true;s.Transparency=1;s.ZIndex=zi;s.Color=col;s.Position=pos;s.Size=size;s.Filled=fill;return s;end local function tx(zi,col,pos,text,sz,center) local t=_Drawing.new("Text");t.Visible=true;t.Transparency=1;t.ZIndex=zi;t.Color=col;t.Position=pos;t.Text=text;t.Size=sz;t.Center=center or false ;t.Outline=true;t.Font=2;return t;end local clDrawings={};local function buildChangelog() for _,v in pairs(clDrawings) do pcall(function() v:Remove();end);end clDrawings={};local function addSq(...) local s=sq(...);table.insert(clDrawings,s);return s;end local function addTx(...) local t=tx(...);table.insert(clDrawings,t);return t;end local p=clPos;addSq(50,BX.bg,p,Vector2.new(CL_W,CL_H),true);addSq(51,BX.acc,p,Vector2.new(CL_W,2),true);addSq(51,BX.title,p,Vector2.new(CL_W,CL_TH),true);addTx(52,BX.white,p + Vector2.new(10,7) ,"Changlogs",16);addTx(52,BX.dim,p + Vector2.new(98,10) ,"v4.0",12);CL.closeBtn=addSq(52,BX.close,p + Vector2.new(CL_W-28 ,3) ,Vector2.new(24,24),true);addTx(53,BX.white,p + Vector2.new(CL_W-21 ,6) ,"X",14);addSq(51,BX.sep,p + Vector2.new(0,CL_TH) ,Vector2.new(CL_W,1),true);addSq(50,BX.panel,p + Vector2.new(0,CL_TH + 1 ) ,Vector2.new(CL_W,(CL_H-CL_TH) -1 ),true);local yOff=CL_TH + 10 ;for _,entry in ipairs(CHANGELOG_ENTRIES) do addSq(51,BX.tabOn,p + Vector2.new(8,yOff) ,Vector2.new(CL_W-16 ,22),true);addSq(51,BX.acc,p + Vector2.new(8,yOff) ,Vector2.new(3,22),true);addTx(52,BX.acc,p + Vector2.new(16,yOff + 4 ) ,entry.version,13);addTx(52,BX.dim,p + Vector2.new(CL_W-80 ,yOff + 4 ) ,entry.date,11);yOff=yOff + 26 ;for _,change in ipairs(entry.changes) do if ((yOff + 16)<(CL_H-8)) then addTx(52,BX.dim,p + Vector2.new(14,yOff + 2 ) ,"•",11);addTx(52,BX.white,p + Vector2.new(24,yOff + 2 ) ,change,11);yOff=yOff + 16 ;end end yOff=yOff + 6 ;end CL._built=true;end local function setCLVisible(v) for _,d in pairs(clDrawings) do d.Visible=v;end end local function clHitTitle(m) return (m.X>=clPos.X) and (m.X<=((clPos.X + CL_W) -32)) and (m.Y>=clPos.Y) and (m.Y<=(clPos.Y + CL_TH)) ;end local function clHitClose(m) if  not CL.closeBtn then return false;end local p=CL.closeBtn.Position;local s=CL.closeBtn.Size;return (m.X>=p.X) and (m.X<=(p.X + s.X)) and (m.Y>=p.Y) and (m.Y<=(p.Y + s.Y)) ;end local function moveCL(newPos) local delta=newPos-clPos ;clPos=newPos;for _,d in pairs(clDrawings) do pcall(function() d.Position=d.Position + delta ;end);end end local AP={ParryCooldown=20,LastParryTime= -100,IsParrying=false,ParryFiring=false,WatchedKillers={},AttachedChars={},SPEED_SAMPLE_INTERVAL=0.05,SPEED_SPIKE_THRESHOLD=28,lastKillerPos=nil,lastSpeedSampleTime=0,killerSpeeds={},SPEED_BUFFER_SIZE=6,inLungeState=false,lungeCooldown=0,ANIM_WINDOW=0.5,pendingParryExpiry=0,killerInMyRadius=false,hasParriedThisEntry=false,MY_RADIUS=3,KILLER_NEAR=5,KILLER_FAR=15};local AP_AtkAnimIds={["rbxassetid://105374834496520"]=true,["rbxassetid://138720291317243"]=true,["rbxassetid://115244153053858"]=true,["rbxassetid://117070354890871"]=true,["rbxassetid://117042998468241"]=true,["rbxassetid://129918027564423"]=true,["rbxassetid://110355011987939"]=true,["rbxassetid://118907603246885"]=true,["rbxassetid://122812055447896"]=true,["rbxassetid://113255068724446"]=true,["rbxassetid://129784271201071"]=true};local function ap_getDist(a,b) local dx,dy,dz=a.X-b.X ,a.Y-b.Y ,a.Z-b.Z ;return math.sqrt((dx * dx) + (dy * dy) + (dz * dz) );end local function ap_isKiller(p) if ( not p or  not p.Parent) then return false;end return p.Team and (p.Team.Name=="Killer") ;end local function ap_amIKiller() return ap_isKiller(localPlayer);end local function ap_getKiller() for _,p in ipairs(players:GetPlayers()) do if ((p~=localPlayer) and ap_isKiller(p) and p.Character and p.Character:FindFirstChild("HumanoidRootPart")) then return p;end end return nil;end local function ap_getMyRoot() return localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") ;end local function ap_avgSpeed() if ( #AP.killerSpeeds==0) then return 0;end local s=0;for _,v in ipairs(AP.killerSpeeds) do s=s + v ;end return s/ #AP.killerSpeeds ;end local function ap_openParryWindow(reason) local now=os.clock();if (now<AP.pendingParryExpiry) then return;end AP.pendingParryExpiry=now + AP.ANIM_WINDOW ;end local uiVis=true;local function ap_fireParryNow(reason) if AP.ParryFiring then return;end if AP.hasParriedThisEntry then return;end if ap_amIKiller() then return;end if  not S.autoParryEnabled then return;end local now=os.clock();if ((now-AP.LastParryTime)<AP.ParryCooldown) then return;end local r=ap_getMyRoot();local k=ap_getKiller();if ( not r or  not k) then return;end local kr=k.Character and k.Character:FindFirstChild("HumanoidRootPart") ;if  not kr then return;end if (ap_getDist(kr.Position,r.Position)>AP.MY_RADIUS) then return;end AP.pendingParryExpiry=0;AP.hasParriedThisEntry=true;print("[AP FIRED] "   .. reason   .. " | ping="   .. S.pingMode );AP.LastParryTime=os.clock();AP.ParryFiring=true;AP.IsParrying=true;_setrobloxinput(true);mouse2press();wait(0.08);mouse2release();_setrobloxinput( not uiVis);AP.IsParrying=false;AP.ParryFiring=false;print("[AP DONE]");end local function ap_onAttackAnim(animId) if AP.ParryFiring then return;end local now=os.clock();if (now>AP.pendingParryExpiry) then return;end if ((now-AP.LastParryTime)<AP.ParryCooldown) then return;end if ap_amIKiller() then return;end if  not S.autoParryEnabled then return;end local r=ap_getMyRoot();local k=ap_getKiller();if ( not r or  not k) then return;end local kr=k.Character and k.Character:FindFirstChild("HumanoidRootPart") ;if  not kr then return;end if (ap_getDist(kr.Position,r.Position)>AP.MY_RADIUS) then return;end local d=PING_DELAYS[S.pingMode] or 0 ;if (d>0) then delay(d,function() ap_fireParryNow("Anim");end);else ap_fireParryNow("Anim");end end local function ap_attachAnimWatcher(killer,char) if  not char then return;end local hum=char:FindFirstChildOfClass("Humanoid") or char:WaitForChild("Humanoid",10) ;if  not hum then return;end local animator=hum:FindFirstChildOfClass("Animator") or hum:WaitForChild("Animator",10) ;if  not animator then return;end local seenTracks={};spawn(function() while char and char.Parent and killer and killer.Parent  do wait(0.05);local ok,tracks=pcall(function() return animator:GetPlayingAnimationTracks();end);if (ok and tracks) then for _,track in ipairs(tracks) do local animId=(track.Animation and track.Animation.AnimationId) or "" ;if (AP_AtkAnimIds[animId] and  not seenTracks[track]) then seenTracks[track]=true;ap_onAttackAnim(animId);delay(2,function() seenTracks[track]=nil;end);end end end end end);end local AP_RING_SEGMENTS=64;local ap_myLines={};local ap_nearLines={};local ap_farLines={};for i=1,AP_RING_SEGMENTS do local m=_Drawing.new("Line");m.Visible=false;m.Thickness=2;m.Transparency=1;m.ZIndex=5;local n=_Drawing.new("Line");n.Visible=false;n.Thickness=1;n.Transparency=1;n.ZIndex=4;n.Color=Color3.fromRGB(255,80,80);local f=_Drawing.new("Line");f.Visible=false;f.Thickness=1;f.Transparency=1;f.ZIndex=4;f.Color=Color3.fromRGB(220,220,220);ap_myLines[i]=m;ap_nearLines[i]=n;ap_farLines[i]=f;end local function ap_hideLines(lines) for i=1,AP_RING_SEGMENTS do lines[i].Visible=false;end end local function ap_drawRing(lines,center,radius) local step=(2 * math.pi)/AP_RING_SEGMENTS ;for i=1,AP_RING_SEGMENTS do local a1=(i-1) * step ;local a2=i * step ;local p1=Vector3.new(center.X + (math.cos(a1) * radius) ,center.Y,center.Z + (math.sin(a1) * radius) );local p2=Vector3.new(center.X + (math.cos(a2) * radius) ,center.Y,center.Z + (math.sin(a2) * radius) );local s1,on1=_WorldToScreen(p1);local s2,on2=_WorldToScreen(p2);local l=lines[i];if (on1 and on2 and s1 and s2) then l.From=s1;l.To=s2;l.Visible=true;else l.Visible=false;end end end local ap_ringT=0;local function updateAPRings() ap_ringT=ap_ringT + 0.016 ;local myRoot=ap_getMyRoot();local killer=ap_getKiller();local killerHRP=killer and killer.Character and killer.Character:FindFirstChild("HumanoidRootPart") ;if (S.autoParryEnabled and myRoot) then local now=os.clock();local col;if AP.killerInMyRadius then local pulse=(math.sin(ap_ringT * 12 ) + 1)/2 ;col=Color3.fromRGB(255,math.floor(60 + (pulse * 120) ),10);elseif (now<AP.pendingParryExpiry) then local pulse=(math.sin(ap_ringT * 8 ) + 1)/2 ;col=Color3.fromRGB(math.floor(pulse * 50 ),200,255);else col=Color3.fromRGB(255,220,50);end for i=1,AP_RING_SEGMENTS do ap_myLines[i].Color=col;end ap_drawRing(ap_myLines,myRoot.Position,AP.MY_RADIUS);else ap_hideLines(ap_myLines);end if (S.autoParryEnabled and killerHRP) then ap_drawRing(ap_nearLines,killerHRP.Position,AP.KILLER_NEAR);ap_drawRing(ap_farLines,killerHRP.Position,AP.KILLER_FAR);else ap_hideLines(ap_nearLines);ap_hideLines(ap_farLines);end end local function ap_watchPlayer(p) if ( not p or (p==localPlayer)) then return;end if AP.WatchedKillers[p] then return;end AP.WatchedKillers[p]=true;pcall(function() p.CharacterAdded:Connect(function() wait(1);AP.AttachedChars[p.Name]=nil;end);end);end for _,p in ipairs(players:GetPlayers()) do ap_watchPlayer(p);end players.PlayerAdded:Connect(ap_watchPlayer);players.PlayerRemoving:Connect(function(p) AP.WatchedKillers[p]=nil;end);spawn(function() while true do wait(0.016);if ( not S.autoParryEnabled or ap_amIKiller()) then AP.IsParrying=false;AP.ParryFiring=false;AP.inLungeState=false;AP.lastKillerPos=nil;AP.killerInMyRadius=false;AP.pendingParryExpiry=0;else local now=os.clock();local myRoot=ap_getMyRoot();local killer=ap_getKiller();if  not killer then AP.IsParrying=false;AP.ParryFiring=false;AP.inLungeState=false;AP.lastKillerPos=nil;AP.killerInMyRadius=false;AP.pendingParryExpiry=0;else local char=killer.Character;if (char and  not AP.AttachedChars[killer.Name]) then AP.AttachedChars[killer.Name]=char;ap_attachAnimWatcher(killer,char);end local killerRoot=char and char:FindFirstChild("HumanoidRootPart") ;if (myRoot and killerRoot) then local dist=ap_getDist(killerRoot.Position,myRoot.Position);if ((now-AP.lastSpeedSampleTime)>=AP.SPEED_SAMPLE_INTERVAL) then if AP.lastKillerPos then local dt=now-AP.lastSpeedSampleTime ;local moved=ap_getDist(killerRoot.Position,AP.lastKillerPos);local speed=moved/dt ;table.insert(AP.killerSpeeds,speed);if ( #AP.killerSpeeds>AP.SPEED_BUFFER_SIZE) then table.remove(AP.killerSpeeds,1);end local avg=ap_avgSpeed();local spiked=((speed-avg)>AP.SPEED_SPIKE_THRESHOLD) and (dist<=AP.KILLER_FAR) ;if (spiked and (now>AP.lungeCooldown)) then AP.inLungeState=true;AP.lungeCooldown=now + 1.5 ;ap_openParryWindow("LungeSpike");end if (AP.inLungeState and (speed<20) and (dist>AP.KILLER_NEAR)) then AP.inLungeState=false;end end AP.lastKillerPos=killerRoot.Position;AP.lastSpeedSampleTime=now;end local wasIn=AP.killerInMyRadius;AP.killerInMyRadius=dist<=AP.MY_RADIUS ;if (AP.killerInMyRadius and  not wasIn) then ap_openParryWindow("RadiusEnter");local d=PING_DELAYS[S.pingMode] or 0 ;if (d>0) then delay(d,function() ap_fireParryNow("RadiusEnter");end);else ap_fireParryNow("RadiusEnter");end end if ( not AP.killerInMyRadius and wasIn) then AP.pendingParryExpiry=0;AP.hasParriedThisEntry=false;if AP.IsParrying then AP.IsParrying=false;AP.ParryFiring=false;end end end end end end end);local UI={};local WP_BTNS={};local W,H=820,540;local TH=36;local TAB=34;local CY=TH + TAB + 2 ;local BASE=Vector2.new(130,90);UI.bg=sq(10,BX.bg,BASE,Vector2.new(W,H),true);UI.topAccent=sq(11,BX.acc,BASE,Vector2.new(W,2),true);UI.titleBar=sq(12,BX.title,BASE,Vector2.new(W,TH),true);UI.titleTxt=tx(20,BX.white,BASE + Vector2.new(14,8) ,"Violence District",20);UI.titleSub=tx(20,BX.dim,BASE + Vector2.new(168,12) ,"v4",13);UI.closeBtn=sq(20,BX.close,BASE + Vector2.new(W-32 ,4) ,Vector2.new(27,27),true);UI.closeTxt=tx(21,BX.white,BASE + Vector2.new(W-24 ,9) ,"X",15);UI.tabBar=sq(12,BX.tabBr,BASE + Vector2.new(0,TH) ,Vector2.new(W,TAB),true);UI.tabSep=sq(13,BX.sep,BASE + Vector2.new(0,TH + TAB ) ,Vector2.new(W,1),true);UI.contentBg=sq(11,BX.panel,BASE + Vector2.new(0,CY) ,Vector2.new(W,H-CY ),true);local TABS={{id="ESP",lbl="ESP",ox=6},{id="Waypoints",lbl="Waypoints",ox=146},{id="Settings",lbl="Settings",ox=286},{id="AutoParry",lbl="Auto Parry",ox=426}};for _,td in ipairs(TABS) do local tp=BASE + Vector2.new(td.ox,TH + 3 ) ;UI["tab_"   .. td.id ]=sq(14,BX.tabOn,tp,Vector2.new(132,28),true);UI["tabT_"   .. td.id ]=tx(15,BX.white,tp + Vector2.new(28,7) ,td.lbl,15);end UI.tab_cl=sq(14,BX.tabOn,BASE + Vector2.new(W-134 ,TH + 3 ) ,Vector2.new(126,28),true);UI.tabT_cl=tx(15,BX.acc,BASE + Vector2.new(W-130 ,TH + 10 ) ,"Changlogs",13);local function mkToggle(id,pos,lbl,on) local BW,BH=220,38;UI[id   .. "_bg" ]=sq(20,BX.btn,pos,Vector2.new(BW,BH),true);UI[id   .. "_bar" ]=sq(21,BX.acc,pos,Vector2.new(2,BH),true);UI[id   .. "_lbl" ]=tx(22,BX.white,pos + Vector2.new(10,10) ,lbl,14);UI[id   .. "_sts" ]=tx(22,(on and Color3.fromRGB(80,210,120)) or Color3.fromRGB(210,80,80) ,pos + Vector2.new(BW-40 ,10) ,(on and "ON") or "OFF" ,14);end local function mkAction(id,pos,lbl,w) w=w or 220 ;UI[id   .. "_bg" ]=sq(20,BX.btn,pos,Vector2.new(w,38),true);UI[id   .. "_bar" ]=sq(21,BX.accD,pos,Vector2.new(2,38),true);UI[id   .. "_lbl" ]=tx(22,BX.white,pos + Vector2.new(10,10) ,lbl,14);end local function mkPingBtn(id,pos,lbl,w) w=w or 140 ;UI[id   .. "_bg" ]=sq(20,BX.btn,pos,Vector2.new(w,38),true);UI[id   .. "_bar" ]=sq(21,BX.accD,pos,Vector2.new(2,38),true);UI[id   .. "_lbl" ]=tx(22,BX.white,pos + Vector2.new(10,10) ,lbl,14);end local function secLbl(id,pos,text) UI[id]=tx(22,BX.dim,pos,text,11);end local EP=BASE + Vector2.new(0,CY) ;secLbl("esp_s1",EP + Vector2.new(18,12) ,"PLAYERS");secLbl("esp_s2",EP + Vector2.new(438,12) ,"OBJECTS");secLbl("esp_s3",EP + Vector2.new(18,182) ,"CROSSHAIRS");secLbl("esp_s4",EP + Vector2.new(438,182) ,"TELEPORT");secLbl("esp_s5",EP + Vector2.new(18,332) ,"CHAMS");mkToggle("b_surv",EP + Vector2.new(18,32) ,"Survivors",true);mkToggle("b_kill",EP + Vector2.new(18,80) ,"Killers",true);mkToggle("b_spec",EP + Vector2.new(18,128) ,"Spectators",true);mkToggle("b_gen",EP + Vector2.new(438,32) ,"Generators",true);mkToggle("b_pal",EP + Vector2.new(438,80) ,"Pallets",true);mkToggle("b_win",EP + Vector2.new(438,128) ,"Windows",true);mkToggle("b_ch",EP + Vector2.new(18,202) ,"Crosshair",false);mkToggle("b_gch",EP + Vector2.new(18,250) ,"Gun Crosshair",false);mkAction("b_lob",EP + Vector2.new(438,202) ,"Teleport to Lobby");mkToggle("b_chams",EP + Vector2.new(18,352) ,"Chams (3D Limb Wireframe)",false);secLbl("esp_s6",EP + Vector2.new(18,396) ,"When Chams ON: wireframe replaces flat box ESP for players");UI.b_ch_sts.Text="OFF";UI.b_ch_sts.Color=Color3.fromRGB(210,80,80);UI.b_gch_sts.Text="OFF";UI.b_gch_sts.Color=Color3.fromRGB(210,80,80);UI.b_chams_sts.Text="OFF";UI.b_chams_sts.Color=Color3.fromRGB(210,80,80);local ESP_ELS={"esp_s1","esp_s2","esp_s3","esp_s4","esp_s5","esp_s6","b_surv_bg","b_surv_bar","b_surv_lbl","b_surv_sts","b_kill_bg","b_kill_bar","b_kill_lbl","b_kill_sts","b_spec_bg","b_spec_bar","b_spec_lbl","b_spec_sts","b_gen_bg","b_gen_bar","b_gen_lbl","b_gen_sts","b_pal_bg","b_pal_bar","b_pal_lbl","b_pal_sts","b_win_bg","b_win_bar","b_win_lbl","b_win_sts","b_ch_bg","b_ch_bar","b_ch_lbl","b_ch_sts","b_gch_bg","b_gch_bar","b_gch_lbl","b_gch_sts","b_lob_bg","b_lob_bar","b_lob_lbl","b_chams_bg","b_chams_bar","b_chams_lbl","b_chams_sts"};UI.wp_hdr=tx(22,BX.dim,EP + Vector2.new(18,12) ,"WAYPOINTS  (E = Save   X = Teleport   max 21)",11);UI.wp_sub=tx(22,BX.dim,EP + Vector2.new(18,30) ,"Click a waypoint to select it",11);UI.wp_del=sq(20,BX.close,EP + Vector2.new(18,(H-CY) -52 ) ,Vector2.new(180,36),true);UI.wp_dlbl=tx(21,BX.white,EP + Vector2.new(28,(H-CY) -42 ) ,"Delete Selected",14);UI.wp_hdr.Visible=false;UI.wp_sub.Visible=false;UI.wp_del.Visible=false;UI.wp_dlbl.Visible=false;local WP_ELS={"wp_hdr","wp_sub","wp_del","wp_dlbl"};secLbl("set_s1",EP + Vector2.new(18,12) ,"DISPLAY");secLbl("set_s2",EP + Vector2.new(18,202) ,"KEYBINDS");UI.set_info=tx(22,BX.dim,EP + Vector2.new(18,310) ,"Z = Teleport to player\nC = Teleport to generator\nE = Save waypoint    X = Teleport to waypoint",12);mkToggle("b_names",EP + Vector2.new(18,32) ,"Name ESP",true);mkToggle("b_tpen",EP + Vector2.new(18,80) ,"Teleport (Z / C)",true);mkToggle("b_sc",EP + Vector2.new(18,128) ,"Auto Skill Check",false);UI.b_sc_sts.Text="OFF";UI.b_sc_sts.Color=Color3.fromRGB(210,80,80);UI.kb_bg=sq(20,BX.btn,EP + Vector2.new(18,222) ,Vector2.new(320,38),true);UI.kb_bar=sq(21,BX.acc,EP + Vector2.new(18,222) ,Vector2.new(2,38),true);UI.kb_lbl=tx(22,BX.white,EP + Vector2.new(28,232) ,"Toggle Menu Key:",14);UI.kb_sts=tx(22,BX.acc,EP + Vector2.new(278,232) ,"F2",14);local SET_ELS={"set_s1","set_s2","set_info","b_names_bg","b_names_bar","b_names_lbl","b_names_sts","b_tpen_bg","b_tpen_bar","b_tpen_lbl","b_tpen_sts","b_sc_bg","b_sc_bar","b_sc_lbl","b_sc_sts","kb_bg","kb_bar","kb_lbl","kb_sts"};for _,n in ipairs(SET_ELS) do UI[n].Visible=false;end secLbl("ap_s1",EP + Vector2.new(18,12) ,"AUTO PARRY");secLbl("ap_s2",EP + Vector2.new(18,182) ,"PING MODE");mkToggle("b_ap",EP + Vector2.new(18,32) ,"Auto Parry",false);mkPingBtn("b_ping_high",EP + Vector2.new(18,202) ,"High Ping (No delay)",170);mkPingBtn("b_ping_mid",EP + Vector2.new(198,202) ,"Mid Ping (Slight delay)",170);mkPingBtn("b_ping_low",EP + Vector2.new(378,202) ,"Low Ping (Delayed)",170);UI.ap_ping_active=tx(22,BX.acc,EP + Vector2.new(18,250) ,"Active: HIGH PING  (No delay)",14);UI.b_ap_sts.Text="OFF";UI.b_ap_sts.Color=Color3.fromRGB(210,80,80);local AP_ELS={"ap_s1","ap_s2","b_ap_bg","b_ap_bar","b_ap_lbl","b_ap_sts","b_ping_high_bg","b_ping_high_bar","b_ping_high_lbl","b_ping_mid_bg","b_ping_mid_bar","b_ping_mid_lbl","b_ping_low_bg","b_ping_low_bar","b_ping_low_lbl","ap_ping_active"};for _,n in ipairs(AP_ELS) do UI[n].Visible=false;end local function updatePingLabel() local labels={high="HIGH PING  (No delay)",mid="MID PING  (Slight delay)",low="LOW PING  (Delayed)"};UI.ap_ping_active.Text="Active: "   .. (labels[S.pingMode] or "?") ;UI.b_ping_high_bar.Color=BX.accD;UI.b_ping_mid_bar.Color=BX.accD;UI.b_ping_low_bar.Color=BX.accD;if (S.pingMode=="high") then UI.b_ping_high_bar.Color=BX.acc;UI.b_ping_high_lbl.Color=BX.acc;else UI.b_ping_high_lbl.Color=BX.white;end if (S.pingMode=="mid") then UI.b_ping_mid_bar.Color=BX.acc;UI.b_ping_mid_lbl.Color=BX.acc;else UI.b_ping_mid_lbl.Color=BX.white;end if (S.pingMode=="low") then UI.b_ping_low_bar.Color=BX.acc;UI.b_ping_low_lbl.Color=BX.acc;else UI.b_ping_low_lbl.Color=BX.white;end end updatePingLabel();local function rebuildWPBtns() for _,b in pairs(WP_BTNS) do pcall(function() b.bg:Remove();end);pcall(function() b.bar:Remove();end);pcall(function() b.lbl:Remove();end);end WP_BTNS={};local isWP=S.currentTab=="Waypoints" ;for i,wp in ipairs(waypoints) do local row=math.floor((i-1)/3 );local col=(i-1)%3 ;local px=BASE.X + 18 + (col * 268) ;local py=BASE.Y + CY + 52 + (row * 50) ;local sel=S.selectedWP==i ;local bg=sq(20,(sel and BX.tabOn) or BX.btn ,Vector2.new(px,py),Vector2.new(258,42),true);local bar=sq(21,(sel and BX.acc) or BX.accD ,Vector2.new(px,py),Vector2.new(2,42),true);local lbl=tx(22,BX.white,Vector2.new(px + 10 ,py + 12 ),wp.name,14);bg.Visible=uiVis and isWP ;bar.Visible=uiVis and isWP ;lbl.Visible=uiVis and isWP ;table.insert(WP_BTNS,{bg=bg,bar=bar,lbl=lbl,index=i});end end local function switchTab(name) S.currentTab=name;for _,td in ipairs(TABS) do UI["tab_"   .. td.id ].Color=((td.id==name) and BX.tabOn) or BX.tabOf ;end UI.tab_cl.Color=BX.tabOf;local isE=name=="ESP" ;local isW=name=="Waypoints" ;local isSET=name=="Settings" ;local isAP=name=="AutoParry" ;for _,n in ipairs(ESP_ELS) do UI[n].Visible=isE;end for _,n in ipairs(WP_ELS) do UI[n].Visible=isW;end for _,n in ipairs(SET_ELS) do UI[n].Visible=isSET;end for _,n in ipairs(AP_ELS) do UI[n].Visible=isAP;end for _,b in pairs(WP_BTNS) do b.bg.Visible=isW and uiVis ;b.bar.Visible=isW and uiVis ;b.lbl.Visible=isW and uiVis ;end end local function setVis(v) uiVis=v;for _,el in pairs(UI) do el.Visible=v;end updateBlur();blurOverlay.Visible=v;if  not clDead then setCLVisible(v and clVisible );end if v then switchTab(S.currentTab);unlockMouse();_setrobloxinput(false);else for _,b in pairs(WP_BTNS) do b.bg.Visible=false;b.bar.Visible=false;b.lbl.Visible=false;end restoreMouse();_setrobloxinput(true);end end local function inB(el,m) local p=el.Position;local s=el.Size;return (m.X>=p.X) and (m.X<=(p.X + s.X)) and (m.Y>=p.Y) and (m.Y<=(p.Y + s.Y)) ;end local function onSts(id,v) UI[id   .. "_sts" ].Text=(v and "ON") or "OFF" ;UI[id   .. "_sts" ].Color=(v and Color3.fromRGB(80,210,120)) or Color3.fromRGB(210,80,80) ;end local dead=false;local function handleClick(m) if (clVisible and  not clDead and uiVis and clHitClose(m)) then clVisible=false;setCLVisible(false);showNotif("Changlogs","Closed — reopen via tab button","info");return;end if (uiVis and inB(UI.tab_cl,m)) then clVisible= not clVisible;if  not clDead then setCLVisible(clVisible);end if clVisible then showNotif("Changlogs","Opened","info");else showNotif("Changlogs","Hidden","info");end return;end if inB(UI.closeBtn,m) then clDead=true;for _,d in pairs(clDrawings) do pcall(function() d:Remove();end);end clDrawings={};for _,el in pairs(UI) do pcall(function() el:Remove();end);end for _,b in pairs(WP_BTNS) do pcall(function() b.bg:Remove();end);pcall(function() b.bar:Remove();end);pcall(function() b.lbl:Remove();end);end for _,l in ipairs({CH.h,CH.v,CH.gh,CH.gv}) do pcall(function() l:Remove();end);end for n in pairs(playerESP) do removeESP(n);end for o in pairs(objectESP) do removeObjESP(o);end for n in pairs(chamsESP) do removeChamsEntry(n);end ap_hideLines(ap_myLines);ap_hideLines(ap_nearLines);ap_hideLines(ap_farLines);pcall(function() blurOverlay:Remove();end);restoreMouse();_setrobloxinput(true);dead=true;return;end for _,td in ipairs(TABS) do if inB(UI["tab_"   .. td.id ],m) then switchTab(td.id);return;end end if (S.currentTab=="ESP") then if inB(UI.b_surv_bg,m) then S.showSurvivors= not S.showSurvivors;onSts("b_surv",S.showSurvivors);notifyToggle("Survivors ESP",S.showSurvivors);elseif inB(UI.b_kill_bg,m) then S.showKillers= not S.showKillers;onSts("b_kill",S.showKillers);notifyToggle("Killers ESP",S.showKillers);elseif inB(UI.b_spec_bg,m) then S.showSpectators= not S.showSpectators;onSts("b_spec",S.showSpectators);notifyToggle("Spectators ESP",S.showSpectators);elseif inB(UI.b_gen_bg,m) then S.showGenerators= not S.showGenerators;onSts("b_gen",S.showGenerators);notifyToggle("Generator ESP",S.showGenerators);elseif inB(UI.b_pal_bg,m) then S.showPallets= not S.showPallets;onSts("b_pal",S.showPallets);notifyToggle("Pallet ESP",S.showPallets);elseif inB(UI.b_win_bg,m) then S.showWindows= not S.showWindows;onSts("b_win",S.showWindows);notifyToggle("Window ESP",S.showWindows);elseif inB(UI.b_ch_bg,m) then S.showCrosshair= not S.showCrosshair;onSts("b_ch",S.showCrosshair);notifyToggle("Crosshair",S.showCrosshair);elseif inB(UI.b_gch_bg,m) then S.showGunCrosshair= not S.showGunCrosshair;onSts("b_gch",S.showGunCrosshair);notifyToggle("Gun Crosshair",S.showGunCrosshair);elseif inB(UI.b_lob_bg,m) then teleportLobby();showNotif("Teleport","Sent to Lobby","info");elseif inB(UI.b_chams_bg,m) then S.chamsEnabled= not S.chamsEnabled;onSts("b_chams",S.chamsEnabled);notifyToggle("Chams ESP",S.chamsEnabled);end elseif (S.currentTab=="Waypoints") then for _,b in pairs(WP_BTNS) do if inB(b.bg,m) then S.selectedWP=b.index;rebuildWPBtns();showNotif("Selected",(waypoints[b.index] and waypoints[b.index].name) or "?" ,"info");return;end end if inB(UI.wp_del,m) then local name=(S.selectedWP and waypoints[S.selectedWP] and waypoints[S.selectedWP].name) or "None" ;deleteWP();rebuildWPBtns();showNotif("Deleted",name,"warn");end elseif (S.currentTab=="Settings") then if inB(UI.b_names_bg,m) then S.showNames= not S.showNames;onSts("b_names",S.showNames);notifyToggle("Name ESP",S.showNames);elseif inB(UI.b_tpen_bg,m) then S.teleportEnabled= not S.teleportEnabled;onSts("b_tpen",S.teleportEnabled);notifyToggle("Teleport",S.teleportEnabled);elseif inB(UI.b_sc_bg,m) then S.autoSkillCheck= not S.autoSkillCheck;onSts("b_sc",S.autoSkillCheck);notifyToggle("Auto Skill Check",S.autoSkillCheck);elseif inB(UI.kb_bg,m) then S.changingKeybind=true;UI.kb_sts.Text="...";showNotif("Keybind","Press any key...","warn");end elseif (S.currentTab=="AutoParry") then if inB(UI.b_ap_bg,m) then S.autoParryEnabled= not S.autoParryEnabled;onSts("b_ap",S.autoParryEnabled);notifyToggle("Auto Parry",S.autoParryEnabled);elseif inB(UI.b_ping_high_bg,m) then S.pingMode="high";updatePingLabel();showNotif("Ping Mode","HIGH  — No delay","info");elseif inB(UI.b_ping_mid_bg,m) then S.pingMode="mid";updatePingLabel();showNotif("Ping Mode","MID  — 100ms delay","info");elseif inB(UI.b_ping_low_bg,m) then S.pingMode="low";updatePingLabel();showNotif("Ping Mode","LOW  — 200ms delay","info");end end end local dragging,dragStart,dragBase=false,nil,nil;local function rebase(newBase) local d=newBase-BASE ;for _,el in pairs(UI) do pcall(function() el.Position=el.Position + d ;end);end for _,b in pairs(WP_BTNS) do pcall(function() b.bg.Position=b.bg.Position + d ;end);pcall(function() b.bar.Position=b.bar.Position + d ;end);pcall(function() b.lbl.Position=b.lbl.Position + d ;end);end BASE=newBase;end for _,p in ipairs(players:GetPlayers()) do if (p~=localPlayer) then if p.Character then createESP(p);newChamsEntry(p);end pcall(function() p.CharacterAdded:Connect(function() wait(0.5);createESP(p);newChamsEntry(p);end);end);end end players.PlayerAdded:Connect(function(p) pcall(function() p.CharacterAdded:Connect(function() wait(0.5);createESP(p);newChamsEntry(p);end);end);end);players.PlayerRemoving:Connect(function(p) removeESP(p.Name);removeChamsEntry(p.Name);end);scanLoop("Generator","Generator",COLORS.Generator,35);scanLoop("Palletwrong","Pallet",COLORS.Pallet,45);scanLoop("Window","Window",COLORS.Window,50);rebuildWPBtns();switchTab("ESP");buildWatermark();buildChangelog();updateBlur();blurOverlay.Visible=true;for _,el in pairs(UI) do el.Visible=true;end switchTab(S.currentTab);unlockMouse();_setrobloxinput(false);uiVis=true;wait(0.3);showNotif("Violence District","ESP v4 loaded  —  F2 to toggle","on");wait(0.2);showNotif("NEW","Auto Parry tab added","info");local lastM1,lastKeys=false,{};spawn(function() while  not dead do wait(0.01);updateCrosshair();pcall(updatePlayerESP);pcall(updateObjectESP);pcall(updateChamsESP);pcall(AutoSkillCheck);pcall(updateAPRings);local mPos=UserInputService:GetMouseLocation();local m1=isM1();if S.changingKeybind then for kc=1,255 do if (isKey(kc) and KeyNames(kc)) then S.toggleKey=kc;S.changingKeybind=false;UI.kb_sts.Text=KeyNames(kc);showNotif("Keybind Changed","Menu key → "   .. KeyNames(kc) ,"info");wait(0.2);break;end end else local tog=isKey(S.toggleKey);if (tog and  not lastKeys[S.toggleKey]) then setVis( not uiVis);if uiVis then showNotif("Menu","Opened","info");end end lastKeys[S.toggleKey]=tog;if  not uiVis then local e=isKey(69);if (e and  not lastKeys[69]) then saveWP();rebuildWPBtns();showNotif("Waypoint Saved","Waypoint "   ..  #waypoints   .. " saved" ,"on");end lastKeys[69]=e;local x=isKey(88);if (x and  not lastKeys[88]) then teleportWP();if (S.selectedWP and waypoints[S.selectedWP]) then showNotif("Teleport","Jumped to "   .. waypoints[S.selectedWP].name ,"info");end end lastKeys[88]=x;local z=isKey(90);if (z and  not lastKeys[90]) then tpPlayerCH();end lastKeys[90]=z;local c=isKey(67);if (c and  not lastKeys[67]) then tpGenCH();end lastKeys[67]=c;else lastKeys[69]=true;lastKeys[88]=true;lastKeys[90]=true;lastKeys[67]=true;end end if (m1 and  not lastM1) then if wmHit(mPos) then wmDragging=true;wmDragStart=mPos;wmDragBase=wmPos;end end if  not m1 then wmDragging=false;end if (wmDragging and m1) then moveWM(wmDragBase + (mPos-wmDragStart) );end if ( not clDead and clVisible and uiVis) then if (m1 and  not lastM1) then if clHitTitle(mPos) then clDragging=true;clDragStart=mPos;clDragBase=clPos;end end if  not m1 then clDragging=false;end if (clDragging and m1) then moveCL(clDragBase + (mPos-clDragStart) );end end if (uiVis and m1 and  not lastM1) then if (inB(UI.titleBar,mPos) and  not inB(UI.closeBtn,mPos)) then dragging=true;dragStart=mPos;dragBase=BASE;end handleClick(mPos);end if  not m1 then dragging=false;end if (dragging and m1 and uiVis) then rebase(dragBase + (mPos-dragStart) );end lastM1=m1;end _setrobloxinput(true);end);print("[Violence District] ESP v4 loaded — F2 to toggle | Auto Parry tab added"); end
